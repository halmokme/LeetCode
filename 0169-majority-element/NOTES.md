### 구현
​
배열에서 가장 많이 나온 원소를 찾는 문제. <br/>
​
배열을 **정렬**한 뒤에 같은 숫자가 나오는 동안 count++, 다른 숫자가 나올때 max를 갱신해주며 카운트를 초기화해주는 방식으로 풀었는데, 성능이 잘 안나와서 레퍼런스를 참고하니 좋은 풀이가 있었다 <br/>
​
**정렬없이** 배열의 앞부분부터 순회하면서 같은 숫자가 나오면 count++, 다른숫자가 나오면 count--를 하되 count가 0일때 count를 초기화해주며 답을 갱신한다. 말로는 간단해보이는데 코드를 뜯어보면 대단한 발상이라는게 느껴진다<br/>
​
예를 들어 [2,2,1,1,1,2,2]가 주어졌다면 [2,2,1,1]에서 이미 2는 답일 가능성을 잃어버렸으므로 네번째 1까지 왔을때 count가 0이 되고 이 다음 숫자인 1에서 다시 count가 1이 된다. <br/>
[2,2,1,1,1]에서 count가 1이 되고 다시 다음 숫자가 2이므로 count가 0이 되고 그와동시에 맨 마지막 원소인 2에서 count가 1이되고 count가 가장 높은 현재원소인 2가 답이 된다. <br/>
2가 네번 나왔으니 카운트가 4가 되는게 아니라, 1이 된다는 것에 유념하면 이 풀이가 얼마나 대단한지 느껴진다