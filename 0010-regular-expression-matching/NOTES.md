
### 2차원 DP (Google technical interview)

문자열 패턴 문제로 DP 리스트를 2차원으로 구현해야 풀 수 있는 문제다. 개인적으로 난이도가 높게 느껴져서 답을 보고 풀었다.  

문자열s가 패턴p와 부합하는지 찾는데 패턴 중 ' . '와 ' * ' 는 특별한 규칙을 가진다.  
. 은 단일 문자를 대체할 수 있으며 * 는 바로 앞에 나온 문자를 0개에서 무한히 대체할 수 있다.  

 \* << 이놈이 문제다.  

s='aab' p='c\*a\*b'   
이게 왜 true인지 한참을 고민했는데 첫번째 * 가 c를 없앨 수 있고, 두번째 * 가 a를 대체할 수 있어서 p는 aab가 될 수 있다.  

s='aaacaab' p='ab\*a\*ca\*.'  
이것도 true인데 첫번째 * 가 b를 없앨 수 있고, 두번째 * 는 a, 세번째 * 는 a, 마지막.은 b를 대치하므로 aaacaab가 될 수 있다.

<br/>
결국 p는 하나의 고정된 값이 아니라 * 가 값을 없앨수도 대치할수도 있기 때문에, 상태에 따라 달라지기 때문에 결국 단순 dp로는 풀 수 없다.

배열을 이용한 2차원 DP리스트를 구현하기 위해 값을 비교한다.
<br/>

||a|b|*|a|*|c|a|*|.|
|---|---|---|---|---|---|---|---|---|---|
|a|T|F|T|F|T|F|F|F|F|
|a|F|F|T|T|T|F|F|F|F|
|a|F|F|T|T|T|F|F|F|F|
|c|F|F|T|F|T|T|F|T|F|
|a|F|F|T|T|T|F|T|T|T|
|a|F|F|T|T|T|F|F|T|T|
|b|F|F|T|F|T|F|F|T|T|

<br/>

비교하다보면 세가지 규칙을 이용해 연산을 줄일 수 있는데 
1. 비교하려는 두 대상의 값이 같은 경우 그 칸의 값은 대각선 위의 값과 일치한다는 것  
2. 위의 두가지 예시에서 알 수 있듯이 비교하려는 p값이 * 인 경우 왼쪽으로 두칸 옆의 값과 일치할 수 있다는 것(* 가 값을 없앨 수 있어서). 무조건 일치한다는 것은 아니여서 3번 규칙과 같이 봐줘야 한다
3. 비교하려는 p값이 * 인 경우 2번 규칙에 따라 값을 먼저 넣어준 뒤에, 여기서 * 앞의 값이 비교하려는 s값과 같은 경우(p[x-1] === s[y]) 왼쪽 두칸 옆의 값이 true라면 그대로 true를, false라면 바로 위에있는 칸의 값을 따른다.  


규칙을 코드로 나타내면 다음과 같다.

```
if(p[x] === '.' || p[x] === p[y]) a[row][col] = a[row-1][col-1];

if(p[col - 1] === '*') a[0][col] = a[0][col - 2];

if(p[x] === '*') {
  a[row][col] = a[row][col-2];
  if(p[x-1] === '.' || p[x-1] === s[y]) {
    a[row][col] = a[row][col] || a[row-1][col]
  }
}
```

